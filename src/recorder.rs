use crate::events::MacroEvent;
// use std::sync::{Arc, Mutex};
use std::time::Instant;

#[derive(Debug, Clone)]
pub enum RecorderState {
    Idle,
    Recording,
    Paused,
}

pub struct MacroRecorder {
    events: Vec<MacroEvent>,
    state: RecorderState,
    start_time: Option<Instant>,
    pause_start: Option<Instant>,
    total_pause_time: std::time::Duration,
}

impl MacroRecorder {
    pub fn new() -> Self {
        Self {
            events: Vec::new(),
            state: RecorderState::Idle,
            start_time: None,
            pause_start: None,
            total_pause_time: std::time::Duration::ZERO,
        }
    }
    
    pub fn start(&mut self) {
        self.events.clear();
        self.state = RecorderState::Recording;
        self.start_time = Some(Instant::now());
        self.pause_start = None;
        self.total_pause_time = std::time::Duration::ZERO;
        log::info!("Recording started");
    }
    
    pub fn pause(&mut self) {
        if matches!(self.state, RecorderState::Recording) {
            self.state = RecorderState::Paused;
            self.pause_start = Some(Instant::now());
            log::info!("Recording paused");
        }
    }
    
    pub fn resume(&mut self) {
        if matches!(self.state, RecorderState::Paused) {
            self.state = RecorderState::Recording;
            if let Some(pause_start) = self.pause_start.take() {
                self.total_pause_time += pause_start.elapsed();
            }
            log::info!("Recording resumed");
        }
    }
    
    pub fn stop(&mut self) {
        self.state = RecorderState::Idle;
        if let Some(pause_start) = self.pause_start.take() {
            self.total_pause_time += pause_start.elapsed();
        }
        log::info!("Recording stopped with {} events", self.events.len());
    }
    
    pub fn clear(&mut self) {
        self.events.clear();
        self.state = RecorderState::Idle;
        self.start_time = None;
        self.pause_start = None;
        self.total_pause_time = std::time::Duration::ZERO;
    }
    
    pub fn add_event(&mut self, mut event: MacroEvent) {
        if matches!(self.state, RecorderState::Recording) {
            // Adjust timestamp to account for pause time
            if let Some(start_time) = self.start_time {
                let adjusted_time = start_time.elapsed() - self.total_pause_time;
                event.timestamp = adjusted_time.as_secs_f64();
            }
            
            self.events.push(event);
        }
    }
    
    pub fn get_events(&self) -> &Vec<MacroEvent> {
        &self.events
    }
    
    pub fn get_state(&self) -> RecorderState {
        self.state.clone()
    }
    
    pub fn get_duration(&self) -> f32 {
        if let Some(start_time) = self.start_time {
            let total_elapsed = start_time.elapsed();
            let current_pause = if let Some(pause_start) = self.pause_start {
                pause_start.elapsed()
            } else {
                std::time::Duration::ZERO
            };
            
            (total_elapsed - self.total_pause_time - current_pause).as_secs_f32()
        } else {
            0.0
        }
    }
    
    pub fn save_to_file(&self, path: &str) -> Result<(), Box<dyn std::error::Error>> {
        use std::io::Write;
        
        let mut file = std::fs::File::create(path)?;
        
        // Write header comment
        writeln!(file, "# Macro Recording File")?;
        writeln!(file, "# Generated by Rust Macro Recorder")?;
        writeln!(file, "# Format: timestamp;event_type;parameters")?;
        writeln!(file, "# Total events: {}", self.events.len())?;
        writeln!(file, "")?;
        
        // Write events
        for event in &self.events {
            writeln!(file, "{}", event.to_mcr_line())?;
        }
        
        log::info!("Saved {} events to {}", self.events.len(), path);
        Ok(())
    }
    
    pub fn get_event_summary(&self) -> String {
        let mut keyboard_events = 0;
        let mut mouse_clicks = 0;
        let mut mouse_moves = 0;
        let mut mouse_scrolls = 0;
        
        for event in &self.events {
            match event.event_type {
                crate::events::EventType::KeyDown | crate::events::EventType::KeyUp => {
                    keyboard_events += 1;
                }
                crate::events::EventType::MouseDown | crate::events::EventType::MouseUp => {
                    mouse_clicks += 1;
                }
                crate::events::EventType::MouseMove => {
                    mouse_moves += 1;
                }
                crate::events::EventType::MouseScroll => {
                    mouse_scrolls += 1;
                }
            }
        }
        
        format!(
            "ğŸ“Š Summary: {} total events | ğŸ¹ {} keys | ğŸ–±ï¸ {} clicks | ğŸ“ {} moves | ğŸ¡ {} scrolls",
            self.events.len(),
            keyboard_events,
            mouse_clicks,
            mouse_moves,
            mouse_scrolls
        )
    }
}
